## Naming conventions used in this file:
## cca_align_*: functions for aligning cca solutions
## cca_ci_*: functions that take data and return CI's (after alignment)
## bt_{prob,algo}_*method*_{inner,fun}: functions for use with batchtools.
##     prob for problems, algo for algorithms.
##     *method* names the approach.
##     fun is for function to be used in prob/algo definition, inner for inrep function


## * Alignment Functions
##' Align CCA solutions by doing nothing.
##'
##' .. content for \details{} ..
##' @title Non-functional CCA alignment
##' @param fm 
##' @param ref 
##' @return 
##' @author Dan Kessler
##' @export cca_align_nil
cca_align_nil <- function(fm, ref) {

  fm <- cca_trim(fm)

  return(fm)
}

##' Correct sign ambiguity in canonical correlation analysis by requiring that
##' the diagonal of xcoef be non-negative (this is the approach suggested by
##' Anderson 1999). This will also truncate both xcoef and ycoef to have the
##' same number of columns as the length of cor
##'
##' @title Fix cancor signs based on the diagonal
##' @param fm A fitted object returned by cancor (or similar)
##' @param ref Not used
##' @return Object like fm but with possible sign flips
##' @author Dan Kessler
cca_align_posdiag <- function(fm, ref) {

  fm <- cca_trim(fm)
  fm_std <- cca_standardize(fm)

  k <- ncol(fm_std$xcoef)
  signs <- diag(x = nonneg(diag(fm_std$xcoef)), nrow = k, ncol = k)

  fm$xcoef <- fm$xcoef %*% signs
  fm$ycoef <- fm$ycoef %*% signs
  return(fm)
}

##' Correct sign ambiguity in canonical correlation analysis
##'
##'
##' Canonical Correlation Analysis suffers from sign ambiguity in the
##' estimated coefficients. This is because Corr(U, V) = Corr(-U, -V).
##' This function adopts the convention that each canonical
##' coefficient pair (xcoef, ycoef) should satisfy the condition that
##' its maximal element (in absolute value) has positive sign. You may
##' wish to standardize the columns of X and Y prior to initially
##' fitting CCA so that differences in variable scaling do not
##' dominate the identity of the maximal element.
##'
##' Note: This only cares about and tries to fix sign ambiguities in
##' the first K=min(px,py) components.
##' @title Fix cancor signs based on the max entry in each column
##' @param fm A fitted object returned by cancor
##' @param ref Not used
##' @return Same object as returned by cancor after sign-flipping per
##'     the identifiability condition discussed in Details.
##' @author Daniel Kessler
cca_align_posmax <- function(fm, ref) {

  fm <- cca_trim(fm)
  fm_std <- cca_standardize(fm)

  k <- ncol(fm_std$xcoef)

  theta <- rbind(fm_std$xcoef, fm_std$ycoef)

  maxes <- apply(theta, 2, absmax)

  flip <- diag(x = nonneg(maxes), nrow = k, ncol = k)

  fm$xcoef <- fm$xcoef %*% flip
  fm$ycoef <- fm$ycoef %*% flip

  return(fm)
}

cca_align_signflip <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  sim_sign <- nonneg(cca_cos_sim(fm_std, ref_std))

  signs <- diag(sim_sign)

  fm$xcoef <- fm$xcoef %*% diag(signs)
  fm$ycoef <- fm$ycoef %*% diag(signs)

  return(fm)
}

cca_align_greedy <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  sim <- cca_cos_sim(fm_std, ref_std)

  ## decompose into signed similarity
  sim_sign <- nonneg(sim)
  sim_abs <- abs(sim)

  k <- ncol(sim)
  map <- rep(0, k)
  signs <- rep(0, k)
  for (i in 1:k) {
    map[i] <- which.max(sim_abs[i, ])
    signs[i] <- sim_sign[i, map[i]]
    sim_abs[, map[i]] <- 0 # zero-out the selected column
  }

  fm$xcoef <- fm$xcoef[, map] %*% diag(signs)
  fm$ycoef <- fm$ycoef[, map] %*% diag(signs)

  if (!is.null(fm$cor)) {
    fm$cor <- fm$cor[map]
  }

  return(fm)
}

cca_align_hungarian <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  sim <- cca_cos_sim(fm_std, ref_std)

  P <- hungarian_max_signflip(sim)

  fm$xcoef <- fm$xcoef %*% P
  fm$ycoef <- fm$ycoef %*% P

  if (!is.null(fm$cor)) {
    fm$cor <- as.vector(fm$cor %*% abs(P))
  }

  return(fm)
}

## weight by square roots of reference and fitted canonical correlations
cca_align_hungarian_weighted <- function(fm, ref) {
  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  sim <- cca_cos_sim(fm_std, ref_std)

  sim_weighted <- diag(sqrt(ref_std$cor)) %*% sim %*% diag(sqrt(fm_std$cor))

  P <- hungarian_max_signflip(sim_weighted)

  fm$xcoef <- fm$xcoef %*% P
  fm$ycoef <- fm$ycoef %*% P

  if (!is.null(fm$cor)) {
    fm$cor <- as.vector(fm$cor %*% abs(P))
  }

  return(fm)
}

cca_align_procrustes_left <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  rx <- procrustes(fm_std$xcoef, ref_std$xcoef)
  ry <- procrustes(fm_std$ycoef, ref_std$ycoef)

  fm$xcoef <- rx %*% fm$xcoef
  fm$ycoef <- ry %*% fm$ycoef
  fm$cor <- NULL
  return(fm)
}

cca_align_procrustes_right <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  rx <- procrustes(t(fm_std$xcoef), t(ref_std$xcoef))
  ry <- procrustes(t(fm_std$ycoef), t(ref_std$ycoef))

  fm$xcoef <- fm$xcoef %*% t(rx)
  fm$ycoef <- fm$ycoef %*% t(ry)
  fm$cor <- NULL
  return(fm)
}

cca_align_linear_left <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  rx <- ref_std$xcoef %*% pracma::pinv(fm_std$xcoef)
  ry <- ref_std$ycoef %*% pracma::pinv(fm_std$ycoef)

  fm$xcoef <- rx %*% fm$xcoef
  fm$ycoef <- ry %*% fm$ycoef
  fm$cor <- NULL
  return(fm)
}

cca_align_linear_right <- function(fm, ref) {

  fm <- cca_trim(fm)
  ref <- cca_trim(ref)
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  rx <- pracma::pinv(fm_std$xcoef) %*% ref_std$xcoef
  ry <- pracma::pinv(fm_std$ycoef) %*% ref_std$ycoef

  fm$xcoef <- fm$xcoef %*% rx
  fm$ycoef <- fm$ycoef %*% ry
  fm$cor <- NULL
  return(fm)
}

parse_align <- function(align) {
  if (is.function(align)) {
    return(align)
  }
  if (is.character(align)) {
    align <- get(align)
    return(align)
  }
}

## * Utility Functions

##' @title Compute cosine similarity between columns of two matrices
##' @param x Matrix of size n by p
##' @param y Matrix of size n by q
##' @return Matrix of size p by q of cosine similarities. The (i, j) entry has
##'   the similarity between x_i and y_j.
##' @author Daniel Kessler
##'
##' Note that the cosine similarity is not well-defined when there exists a
##' column of all 0's in either x or y.
cos_sim <- function(x, y) {
  x <- scale(x, center = FALSE, scale = sqrt(colSums(x^2)))
  y <- scale(y, center = FALSE, scale = sqrt(colSums(y^2)))

  return(t(x) %*% y)
}

cca_trim <- function(fm) {
  if (!is.null(fm$cor)) {
    k <- length(fm$cor)
    fm$xcoef <- fm$xcoef[, 1:k, drop = FALSE]
    fm$ycoef <- fm$ycoef[, 1:k, drop = FALSE]
  }
  return(fm)
}

cca_standardize <- function(fm) {
  if (!is.null(fm$xsd)) {
    fm$xcoef <- sweep(fm$xcoef, 1, fm$xsd, FUN = "*")
  }
  if (!is.null(fm$ysd)) {
    fm$ycoef <- sweep(fm$ycoef, 1, fm$ysd, FUN = "*")
  }
  return(fm)
}

cca_cos_sim <- function(fm, ref) {
  fm_std <- cca_standardize(fm)
  ref_std <- cca_standardize(ref)

  xsim <- cos_sim(ref_std$xcoef, fm_std$xcoef)
  ysim <- cos_sim(ref_std$ycoef, fm_std$ycoef)
  sim <- (xsim + ysim) / 2

}

##' Compute the CCA with unit variance constraint
##'
##' This is a simple wrapper around stats::cancor. stats::cancor uses the Golub
##' and Van Loan algorithm, which yields canonical variates that have unit norm
##' rather than unit variance.
##' As a result, the canonical variates will have (empirical) variance
##' of 1/(N-1), where N is the number of observations. This is
##' undesirable if we wish to perform inference on the weights in
##' xcoef or ycoef, because their scale will vary with N.
##'
##' This function calls stats::cancor and then multiplies both xcoef and ycoef
##' by sqrt(N-1) so that the resulting canonical variates will indeed have unit
##' variance.
##'
##' In addition, this function adds two new fields to the result, which hold the
##' columnwise standard deviations of x and y, respectively. These fields may be
##' useful for downstream tasks (e.g., alignment).
##'
##' See the documentation for stats::cancor for more details on standard usage.
##'
##' @title Canonical Correlations with Unit Variance
##' @param x one dataset
##' @param y the other dataset
##' @param xcenter whether to center x
##' @param ycenter whether to center y
##' @param align A function for aligning the solution
##' @param ref Passed through to align
##' @return
##' @export cancor_scaled
##' @author Daniel Kessler
cancor_scaled <- function(x, y, xcenter = TRUE, ycenter = TRUE,
                          align = cca_align_nil, ref) {
  n <- nrow(x)
  fm <- stats::cancor(x, y, xcenter, ycenter)
  fm$xcoef <- sqrt(n - 1) * fm$xcoef
  fm$ycoef <- sqrt(n - 1) * fm$ycoef
  fm$xsd <- apply(as.matrix(x), 2, sd)
  fm$ysd <- apply(as.matrix(y), 2, sd)
  align <- parse_align(align)
  fm <- align(fm, ref)
  return(fm)
}

## * CI Functions

##' Obtain confidence intervals for the "directions" of a canonical correlation
##' analysis using asymptotic results from Anderson 1999.
##'
##' Important Note: Theory only valid when p = q.
##' @title Asymptotic confidence intervals for CCA directions
##' @param x Data matrix of size n by p
##' @param y Data matrix of size n by q
##' @param level Level for confidence intervals, should be in (0, 1)
##' @param align A function to perform post-processing on the estimated
##'   coefficients to render the solution well-identified. By default, this uses
##'   cancor_signfix_diag, which ensures that the diagonal of xcoef is
##'   non-negative. Should also take "ref" or "..." as an argument (but doesn't
##'   have to use it). If a string is passed, it will be converted to the
##'   function with the same name.
##' @param ref A reference solution to align against
##' @return List with two objects: xcoef and ycoef.
##' @author Dan Kessler
##' @export
cca_ci_asymptotic <- function(x, y, level = .90,
                              align = cca_align_nil, ref) {
  align <- parse_align(align)
  n <- nrow(x)
  p <- ncol(x)
  q <- ncol(y)
  K <- min(p, q, n)

  fm <- cancor_scaled(x, y)
  align <- parse_align(align)
  fm <- align(fm, ref)
  fm$xcoef <- fm$xcoef[, 1:K]
  fm$ycoef <- fm$ycoef[, 1:K]

  xvar <- matrix(NA, nrow = nrow(fm$xcoef), ncol = ncol(fm$xcoef))
  yvar <- matrix(NA, nrow = nrow(fm$ycoef), ncol = ncol(fm$ycoef))

  for (j in 1:K) {
    for (i in 1:p) {
      runsum <- 0
      for (k in setdiff(1:K, j)) {
        runsum <- runsum +
          with(
            fm,
            (cor[k]^2 + cor[j]^2 - 2 * cor[k]^2 * cor[j]^2) /
              (cor[j]^2 - cor[k]^2)^2 *
              xcoef[i, k]^2
          )
      }
      xvar[i, j] <- 1 / 2 * fm$xcoef[i, j]^2 + (1 - fm$cor[j]^2) * runsum
    }
  }

  for (j in 1:K) {
    for (i in 1:q) {
      runsum <- 0
      for (k in setdiff(1:K, j)) {
        runsum <- runsum +
          with(
            fm,
            (cor[k]^2 + cor[j]^2 - 2 * cor[k]^2 * cor[j]^2) /
              (cor[j]^2 - cor[k]^2)^2 *
              ycoef[i, k]^2
          )
      }
      yvar[i, j] <- 1 / 2 * fm$ycoef[i, j]^2 + (1 - fm$cor[j]^2) * runsum
    }
  }

    zcrit <- - qnorm((1 - level) / 2)

  alpha <- 1 - level
  ci_levels <- paste(c(100 * alpha / 2, 100 * (1 - alpha / 2)), "%")

  adimnames <- list(
    coordinate = NULL,
    component = 1:K,
    ci_levels
  )

  xcoef_ci <- array(NA, c(p, K, 2),
                    dimnames = adimnames)

  ycoef_ci <- array(NA, c(q, K, 2),
                    dimnames = adimnames)

  xcoef_ci[, , 1] <- fm$xcoef - sqrt(xvar / n) * zcrit
  xcoef_ci[, , 2] <- fm$xcoef + sqrt(xvar / n) * zcrit


  ycoef_ci[, , 1] <- fm$ycoef - sqrt(yvar / n) * zcrit
  ycoef_ci[, , 2] <- fm$ycoef + sqrt(yvar / n) * zcrit


  res <- list(xcoef = xcoef_ci, ycoef = ycoef_ci)
  return(res)
}

##' Bootstrap quantiles of absolute differences to generate CCA confidence intervals
##'
##' @title Bootstrap-based confidence intervals for CCA directions
##' @param x Data matrix of size N by p
##' @param y Data matrix of size N by q
##' @param level Level for confidence intervals, should be in (0, 1)
##' @param nboots Number of bootstrap sample to draw
##' @param parametric If FALSE (default), do bootstrap by sampling with
##'   replacement. If TRUE, perform parametric bootstrap, i.e., draw data from
##'   multivariate normal distribution following sample covariance
##' @param progress If 0 (default), don't report progress. If set to a positive
##'   integer k, report bootstrap progress every k'th run.
##' @return List with two objects: xcoef and ycoef.
##' @author Daniel Kessler
##' @export
cca_ci_absboot <- function(x, y, level = .90, align = cca_align_nil, ref,
                             nboots = 1e3, parametric = FALSE, progress = 0) {
  align <- parse_align(align)
  n <- nrow(x)
  p <- ncol(x)
  q <- ncol(y)

  fm <- cancor_scaled(x, y)
  align <- parse_align(align)
  fm <- align(fm, ref)
  K <- length(fm$cor)

  rho_hat <- fm$cor
  xcoef_hat <- fm$xcoef[, 1:K]
  ycoef_hat <- fm$ycoef[, 1:K]

  rho_boot <- array(dim = c(length(rho_hat), nboots))
  xcoef_boot <- array(dim = c(dim(xcoef_hat), nboots))
  ycoef_boot <- array(dim = c(dim(ycoef_hat), nboots))

  for (i in 1:nboots) {
    if (progress && !(i %% progress)) {
      progress_message <- sprintf("Running bootstrap %d of %d", i, nboots)
      print(progress_message)
    }
    idx <- sample(n, replace = TRUE)
    if (!parametric) {
      idx <- sample(n, replace = TRUE)
      fm_boot <- cancor_scaled(x[idx, ], y[idx, ])
    } else {
      if (i == 1) { # only compute cholesky once
        sigma_hat <- cov(cbind(x, y))
        l_hat <- chol(sigma_hat)
      }
      newdata <- t(l_hat %*% matrix(rnorm(n * (p + q)), p + q, n))
      x_boot <- newdata[, 1:p]
      y_boot <- newdata[, (p + 1):(p + q)]
      fm_boot <- cancor_scaled(x_boot, y_boot)
    }
    rho_boot[, i] <- fm_boot$cor
    xcoef_boot[, , i] <- fm_boot$xcoef[, 1:K]
    ycoef_boot[, , i] <- fm_boot$ycoef[, 1:K]
  }

  rho_dist <- abs(sweep(rho_boot, c(1), rho_hat))
  xcoef_dist <- abs(sweep(xcoef_boot, c(1, 2), xcoef_hat))
  ycoef_dist <- abs(sweep(ycoef_boot, c(1, 2), ycoef_hat))

  rho_t <- apply(rho_dist, 1, quantile, probs = level)
  xcoef_t <- apply(xcoef_dist, c(1, 2), quantile, probs = level)
  ycoef_t <- apply(ycoef_dist, c(1, 2), quantile, probs = level)

  rho_ci <- array(c(rho_hat - rho_t, rho_hat, rho_hat + rho_t),
    dim = c(K, 3),
    dimnames = list(Component = 1:K, Interval = c("Lower", "Estimate", "Upper"))
  )

  alpha <- 1 - level
  ci_levels <- paste(c(100 * alpha / 2, 100 * (1 - alpha / 2)), "%")

  adimnames <- list(
    coordinate = NULL,
    component = 1:K,
    ci_levels
  )

  xcoef_ci <- array(NA, c(p, K, 2),
                    dimnames = adimnames)

  ycoef_ci <- array(NA, c(q, K, 2),
                    dimnames = adimnames)

  xcoef_ci[, , 1] <- xcoef_hat - xcoef_t
  xcoef_ci[, , 2] <- xcoef_hat + xcoef_t

  ycoef_ci[, , 1] <- ycoef_hat - ycoef_t
  ycoef_ci[, , 2] <- ycoef_hat + ycoef_t


  res <- list(xcoef = xcoef_ci, ycoef = ycoef_ci)
  return(res)
}

##' Obtain confidence intervals for canonical correlation analysis directions by
##' taking a regression-approach
##'
##' The idea of the regression approach is to recast the CCA problem as a
##' regression problem. First, select a proportion of the data equal to
##' \code{train_ratio} of the data (rounding down as necessary). Then, estimate
##' the usual CCA parameters on this partition: these include \code{cor} (the
##' canonical correlation coefficients), \code{xcoef}, (the canonical directions
##' associated with x), and \code{ycoef} (the canonical directions associated
##' with y).
##'
##' Use the canonical directions estimated above to construct new canonical
##' variables in the held-out partition (by taking the inner product between
##' each observation and a given canonical direction). Then, fit many regression
##' models where we predict one canonical variable using the other dataset. For
##' each, apply a transformation such that the predicted values have unit
##' variance (to satisfy the CCA constraint). Finally, use conventional
##' regression-based inference to provide confidence intervals for the
##' coefficients.
##' @title Regression-Based Confidence Intervals for CCA Directions
##' @param x Data matrix of size n by p
##' @param y Data matrix of size n by q
##' @param level Level for confidence intervals, should be in (0, 1)
##' @param train_ratio What proportion of the data should be used for estimating
##'   CCA directions
##' @return List with two objects: xcoef and ycoef.
##' @author Dan Kessler
##' @export
cca_ci_regression <- function(x, y, level = .90, align = cca_align_nil, ref,
                              train_ratio = 0.5) {
  align <- parse_align(align)
  n <- nrow(x)
  p <- ncol(x)
  q <- ncol(y)

  n_train <- floor(n * train_ratio)
  train_ind <- sample.int(n, size = n_train, replace = FALSE)

  x1 <- x[+train_ind, ]
  x2 <- x[-train_ind, ]
  y1 <- y[+train_ind, ]
  y2 <- y[-train_ind, ]

  fm1 <- cancor_scaled(x1, y1)
  fm1 <- align(fm1, ref)
  K <- length(fm1$cor)

  x2scores <- x2 %*% fm1$xcoef[, 1:K]
  y2scores <- y2 %*% fm1$ycoef[, 1:K]

  alpha <- 1 - level
  ci_levels <- paste(c(100 * alpha / 2, 100 * (1 - alpha / 2)), "%")

  adimnames <- list(
    coordinate = NULL,
    component = 1:K,
    ci_levels
  )

  xcoef_ci <- array(NA, c(p, K, 2),
                    dimnames = adimnames)

  ycoef_ci <- array(NA, c(q, K, 2),
                    dimnames = adimnames)

  for (k in 1:K) {
    fm2_xpred <- lm_scalefix(lm(y2scores[, k] ~ x2))
    fm2_ypred <- lm_scalefix(lm(x2scores[, k] ~ y2))


    xcoef_ci[, k, 1] <- confint(fm2_xpred, level = level)[-1, 1]
    xcoef_ci[, k, 2] <- confint(fm2_xpred, level = level)[-1, 2]

    ycoef_ci[, k, 1] <- confint(fm2_ypred, level = level)[-1, 1]
    ycoef_ci[, k, 2] <- confint(fm2_ypred, level = level)[-1, 2]
  }

  res <- list(xcoef = xcoef_ci, ycoef = ycoef_ci)
  return(res)
}

##' Use the boot package to get bootstrapped confidence intervals for CCA
##'
##' Details go here
##' @title Bootstrap-based confidence intervals for CCA
##' @param x Data matrix of size n by p
##' @param y Data matrix of size n by q
##' @param level Level for confidence intervals, should be in (0, 1)
##' @param align Function for alignment
##' @param ref Passed through to align function
##' @param nboots How many bootstrap replicates
##' @param ncpus How many cpu's to use to parallelize bootstrap. If > 1, then
##'   "multicore" will be used
##' @param boot_type Which bootstrap methods to use; see type argument of
##'   boot::boot.ci
##' @param return_boot Whether to return the (potentially very large) boot_out
##'   object created by the bootstrap function. Defaults to FALSE
##' @return List of several types of CIs
##' @author Dan Kessler
##' @export cca_ci_boot
cca_ci_boot <- function(x, y, level=0.90, align = cca_align_nil,
                        ref, nboots = 1e2, ncpus = 1,
                        boot_type = c("norm", "basic", "perc", "bca"),
                        return_boot = FALSE) {
  align <- parse_align(align)
  n <- nrow(x)
  p <- ncol(x)
  q <- ncol(y)
  K <- min(p, q, n)

  data_flat <- cbind(x, y)

  boot_stat <- function(data, idx, p, align, ref) {
    bdata <- data[idx, ]
    theta <- cancor_vec(bdata, p, align, ref)
    return(theta)
  }

  if (ncpus > 1) {
    parallel <- "multicore"
  } else {
    parallel <- "no"
  }

  boot_out <- boot::boot(data_flat,
    R = nboots,
    statistic = boot_stat,
    p = p,
    align = align,
    ref = ref,
    parallel = parallel,
    ncpus = ncpus
  )

  ## preallocate for results
  numel <- (p + q) * K

  ci_glue <- function(ci_flat) {
    alpha <- 1 - level
    ci_levels <- paste0(c(100 * alpha / 2, 100 * (1 - alpha / 2)), "%")
    adimnames <- list(
      coordinate = NULL,
      component = 1:K,
      ci_levels
    )

    ci_lower <- vec2fm(ci_flat[, 1], p, q)
    ci_upper <- vec2fm(ci_flat[, 2], p, q)

    xcoef_ci <- abind::abind(ci_lower$xcoef, ci_upper$xcoef, along = 3)
    dimnames(xcoef_ci) <- adimnames

    ycoef_ci <- abind::abind(ci_lower$ycoef, ci_upper$ycoef, along = 3)
    dimnames(ycoef_ci) <- adimnames

    fm <- list(xcoef = xcoef_ci, ycoef = ycoef_ci)
    return(fm)
  }

  ci_by_method <- function(method) {
    ci_flat <- array(NA, c(numel, 2))

    for (i in seq_len(numel)) {
      bootci <- boot::boot.ci(
        boot.out = boot_out,
        conf = level,
        type = method,
        index = i
      )

      method_cis <- bootci[[method, exact = FALSE]] # extract the object
      method_cis <- method_cis[
        ,
        (ncol(method_cis) - 1):ncol(method_cis)
      ] # last 2 columns

      ci_flat[i, ] <- method_cis
    }
    return(ci_glue(ci_flat))
  }

  cca_ci_absboot_boot <- function() {
    ## make absboot style CI's using boot_out
    abs_devs <- abs(sweep(boot_out$t, c(2), boot_out$t0))
    abs_t <- apply(abs_devs, 2, quantile, probs = level)

    ci_lower <- vec2fm(boot_out$t0 - abs_t, p, q)
    ci_upper <- vec2fm(boot_out$t0 + abs_t, p, q)

    alpha <- 1 - level
    ci_levels <- paste0(c(100 * alpha / 2, 100 * (1 - alpha / 2)), "%")
    adimnames <- list(
      coordinate = NULL,
      component = 1:K,
      ci_levels
    )

    xcoef_ci <- abind::abind(ci_lower$xcoef, ci_upper$xcoef, along = 3)
    dimnames(xcoef_ci) <- adimnames

    ycoef_ci <- abind::abind(ci_lower$ycoef, ci_upper$ycoef, along = 3)
    dimnames(ycoef_ci) <- adimnames

    fm <- list(xcoef = xcoef_ci, ycoef = ycoef_ci)
    return(fm)
  }

  res <- lapply(boot_type, ci_by_method) # loop over requested boot methods

  res$ci_absboot <- cca_ci_absboot_boot() # get absboot results

  names(res) <- c(boot_type, "AbsBoot")                # preserve method names
  if(return_boot) res$boot_out <- boot_out
  return(res)
}

cca_ci_laha <- function(x, y, level = 0.90,
                        align = cca_align_nil, ref) {

  align <- parse_align(align)
  n <- nrow(x)
  p <- ncol(x)
  q <- ncol(y)
  K <- min(p, q, n)

  fm <- cancor_scaled(x, y)
  align <- parse_align(align)
  fm <- align(fm, ref)
  fm$xcoef <- fm$xcoef[, 1:K]
  fm$ycoef <- fm$ycoef[, 1:K]

  xvar <- matrix(NA, nrow = nrow(fm$xcoef), ncol = ncol(fm$xcoef))
  yvar <- matrix(NA, nrow = nrow(fm$ycoef), ncol = ncol(fm$ycoef))

  laha <- de.bias.cca::give_CCA(fm$xcoef[, 1], fm$ycoef[, 1], x, y)

  rho_hat <- c(sqrt(laha[[4]]))
  xvar[, 1] <- laha[[3]][1:p]
  yvar[, 1] <- laha[[3]][(p + 1) : (p + q)]

  zcrit <- - qnorm((1 - level) / 2)

  alpha <- 1 - level
  ci_levels <- paste(c(100 * alpha / 2, 100 * (1 - alpha / 2)), "%")

  adimnames <- list(
    coordinate = NULL,
    component = 1:K,
    ci_levels
  )

  xcoef_ci <- array(NA, c(p, K, 2),
                    dimnames = adimnames)

  ycoef_ci <- array(NA, c(q, K, 2),
                    dimnames = adimnames)

  xcoef_ci[, , 1] <- fm$xcoef - 2 * sqrt(xvar) * zcrit / (sqrt(n) * sqrt(rho_hat))
  xcoef_ci[, , 2] <- fm$xcoef + 2 * sqrt(xvar) * zcrit / (sqrt(n) * sqrt(rho_hat))


  ycoef_ci[, , 1] <- fm$ycoef - 2 * sqrt(yvar) * zcrit / (sqrt(n) * sqrt(rho_hat))
  ycoef_ci[, , 2] <- fm$ycoef + 2 * sqrt(yvar) * zcrit / (sqrt(n) * sqrt(rho_hat))


  res <- list(xcoef = xcoef_ci, ycoef = ycoef_ci)
  return(res)
}

##' @title Refit a linear model such that predicted values have unit variance
##' @param fm An object fitted with lm
##' @return An object of type lm refit such that predicted values have unit
##'   variance
##' @author Dan Kessler
lm_scalefix <- function(fm) {
  y <- fm$model[[1]] # extract response
  x <- fm$model[[2]] # extract predictors
  y_tilde <- y / sd(predict(fm))
  fm_tilde <- lm(y_tilde ~ x)
  return(fm_tilde)
}

## * Simulation Support
## code to support simulation studies of CCA

sim.coverage.check <- function(n, px, py) {
  Sigma <- generate.sigma(px, py)
  dat <- generate.data(n, Sigma, px)
  X <- dat$X
  Y <- dat$Y

  pop.fm <- cancor_cov(Sigma, px)

  boot.cis <- bootstrapcca(X, Y)
}

##' @title Conduct asymptotic coverage experiment
##' @param outreps Each "outer replication" draws a new value of sigma. This can
##'   either be an integer (e.g., 10L), in which case a random covariance matrix
##'   will be drawn for each out replication, or instead it can be a list whose
##'   length determines the number of replications, and whose values are
##'   covariance matrices to use.
##' @param inreps Each "inner replication" is a repetition with new data for the
##'   same value of sigma
##' @param p The dimension of X
##' @param q The dimension of Y
##' @param n How many datapoints to draw in each sample
##' @param nboots How many bootstrap samples to draw
##' @param sigma Optional. A list of length outreps containing covariance
##'   matrices of size p + q. This matrices will be used for each of the outreps
##'   replications. If not provided, a covariance matrix will be generated for
##'   you for each of the outreps.
##' @return A list of results, containing: (1) truth, a 4D array of true
##'   parameter values, (2) cover, a 5D array of logicals indicating which CIs
##'   cover the truth, (3) length, a 5D array of CI lengths, (4) cis, a 6D array
##'   of the confidence intervals, and (5) sigma, a list of length outreps the
##'   holds the generative Sigma. For the arrays, the dimensions (as applicable)
##'   index (i) coordinates (p+q), (ii) components (K), (iii) inreps, (iv)
##'   outreps, (v) method, (vi) lower/upper confidence bounds.
##' @export
##' @author Dan Kessler
coverage_experiment <- function(outreps = 1L, inreps = 1L, p = 2, q = 2,
                                n = 1000L, nboots = 1000L) {
  K <- min(p, q, n)
  coord_names <- c(paste0("X_", 1:p), paste0("Y_", 1:q))

  methods <- c(
    "asymptotic",
    "split-regression",
    "bootstrap-abs"
  )

  M <- length(methods) # number of methods

  if (is.integer(outreps)) {
    sigma <- list()
    for (i in 1:outreps) {
      sigma[[i]] <- gen_sigma(p, q)
    }
  } else if (is.list(outreps)) {
    sigma <- outreps
    outreps <- length(sigma)
  }

  cis <- array(NA, c((p + q), K, inreps, outreps, M, 2),
    dimnames = list(
      coordinate = coord_names,
      component = 1:K,
      inreps = 1:inreps,
      outreps = 1:outreps,
      method = methods,
      quantity = c("lower", "upper")
    )
  )

  cover <- array(NA, c((p + q), K, inreps, outreps, M),
    dimnames = list(
      coordinate = coord_names,
      component = 1:K,
      inreps = 1:inreps,
      outreps = 1:outreps,
      method = methods)
  )

  length <- cover

  truth <- array(NA, c((p + q), K, inreps, outreps),
    dimnames = list(
      coordinate = coord_names,
      component = 1:K,
      inreps = 1:inreps,
      outreps = 1:outreps)
  )



  for (i in 1:outreps) {
    fm_true <- cancor_cov(sigma[[i]], px = p)
    for (j in 1:inreps) {
      dat <- gen_data(sigma[[i]], p, q, n)
      truth[1:p, , j, i] <- fm_true$xcoef
      truth[(p + 1):(p + q), , j, i] <- fm_true$ycoef

      ## asymptotic
      ci_estimates <- cca_ci_asymptotic(dat$x, dat$y)
      cis[1:p, , j, i, 1, 1] <- ci_estimates$xcoef[, , 1]
      cis[1:p, , j, i, 1, 2] <- ci_estimates$xcoef[, , 2]
      cis[(p + 1):(p + q), , j, i, 1, 1] <- ci_estimates$ycoef[, , 1]
      cis[(p + 1):(p + q), , j, i, 1, 2] <- ci_estimates$ycoef[, , 2]

      ## regression
      ci_estimates <- cca_ci_regression(dat$x, dat$y)
      cis[1:p, , j, i, 2, 1] <- ci_estimates$xcoef[, , 1]
      cis[1:p, , j, i, 2, 2] <- ci_estimates$xcoef[, , 2]
      cis[(p + 1):(p + q), , j, i, 2, 1] <- ci_estimates$ycoef[, , 1]
      cis[(p + 1):(p + q), , j, i, 2, 2] <- ci_estimates$ycoef[, , 2]

      ## bootstrap-abs
      ci_estimates <- cca_ci_bootstrap(dat$x, dat$y, nboots = 10)
      cis[1:p, , j, i, 3, 1] <- ci_estimates$xcoef[, , 1]
      cis[1:p, , j, i, 3, 2] <- ci_estimates$xcoef[, , 2]
      cis[(p + 1):(p + q), , j, i, 3, 1] <- ci_estimates$ycoef[, , 1]
      cis[(p + 1):(p + q), , j, i, 3, 2] <- ci_estimates$ycoef[, , 2]
    }
  }

  for (m in 1:M) {
    cover[, , , , m] <- cis[, , , , m, 1] <= drop(truth) &
      drop(truth) <= cis[, , , , m, 2]

    length[, , , , m] <- cis[, , , , m, 2] - cis[, , , , m, 1]
  }

  return(list(cis = cis, truth = truth, cover = cover,
              length = length, sigma = sigma))
}

##' Draw data for use in CCA estimation according to a user-specified covariance
##' matrix.
##'
##' @title Draw CCA data according to covariance Sigma
##' @param Sigma Square, positive definite covariance matrix with p + q
##'   rows/cols
##' @param p The dimension of the random variable X
##' @param q The dimension of the random variable Y
##' @param n The number of observations to draw
##' @return A list with two fields: x and y. They are matrices of size n by p
##'   and n by q, respectively.
##' @author Dan Kessler
##' @export gen_data
gen_data <- function(Sigma, p, q, n) {
  Sigma_r <- chol(Sigma)

  newdata <- t(t(Sigma_r) %*% matrix(rnorm(n * (p + q)), p + q, n))
  x <- newdata[, 1:p]
  y <- newdata[, (p + 1):(p + q)]
  res <- list(x = x, y = y)
  return(res)
}

##' Generate a square covariance matrix for use with CCA.
##'
##' For CCA simulation studies, it is convenient to be able to generate a
##' "random" covariance matrix. The current approach proceeds by constructing
##' Gamma (the canonical directions associated with Y), Beta (the canonical
##' directions associated with X), and rho (the canonical correlations
##' themselves). It then inverts the CCA formulation (using cancor_inv_cov) so
##' that the resultant covariance matrix (Sigma) would, if subjected to CCA
##' (e.g., with cancor_cov), yield Gamma, Beta, and rho.
##'
##' Both Gamma and Beta are constructed with iid standard normal entries,
##' although the second coordinate of the first canonical direction associated
##' with Y can be manually specified (as the argument gamma21).
##'
##' Next, a sequence of the canonical correlations are generated. Currently, the
##' largest canonical correlation will be set to rho_max. The remaining
##' canonical correlations will begin at rho_max - rho_gap and then decay
##' exponentially according to (rho_max - rho_gap)^((t - 1) * rho_decay), where
##' t is an integer that indicates the index of the canonical correlation.
##'
##' It is contingent on the user to ensure that rho_max is in (0, 1) and that
##' rho_max minus rho_gap is strictly greater than 0.
##'
##' Note: If p \neq q, then the inverse mapping is not unique. See the
##' documentation of cancor_inv_cov for details of how this is handled.
##'
##'
##' @title Generate random covariance matrix for CCA
##' @param p Dimension of X random variable
##' @param q Dimension of Y random variable
##' @param rho_max The largest canonical correlation (must be between 0 and 1)
##' @param rho_gap The gap between the largest and second-largest canonical
##'   correlation
##' @param rho_decay The rate at which the canonical correlations (after the
##'   first) decay. Should be a strictly positive number. Small values will give
##'   very gradual decay and poor spacing, very large values will asymptote at 0
##'   very quickly and also give poor spacing. See details for more information.
##' @param gamma21 User-specified value for the second element of the first
##'   canonical direction associated with Y. If NULL (default) then this will be
##'   iid N(0, 1) like the rest of Gamma.
##' @return A square, positive definite matrix with p+q rows/cols
##' @author Dan Kessler
gen_sigma <- function(p, q, rho_max = 0.9, rho_gap = 0.1, rho_decay = 1,
                      gamma21 = NULL) {

  K <- min(p, q)

  Gamma <- matrix(rnorm(q * K), nrow = q, ncol = K)
  Beta <- matrix(rnorm(p * K), nrow = p, ncol = K)

  if (!is.null(gamma21)) {
    Gamma[2, 1] <- gamma21
  }

  rho <- rep(0, K)
  rho[1] <- rho_max
  rho[2:K] <- (rho_max - rho_gap)^(rho_decay * (2:K - 1))

  sigma <- cancor_inv_cov(Beta, Gamma, rho)
  return(sigma)
}

##' @title Generate covariance matrix for CCA
##' @param p Dimension of X random variable
##' @param q Dimension of Y random variable
##' @param cov_type Either "id" or "sPrec"
##' @param rho_1 The largest canonical correlation
##' @param rho_1 The second-largest canonical correlation
##' @param type Either "sparse", "constant", or "random"
##' @return A square, positive definite matrix with p+q rows/cols
##' @author Dan Kessler
##' @export gen_sigma2
gen_sigma2 <- function(p, q, cov_type, rho1, rho2, type = "sparse") {
  if (cov_type == "id") {
    sxx <- diag(p)
    syy <- diag(q)
  }

  if (cov_type == "sPrec") {
    sxx <- gen_sPrec(p)
    syy <- gen_sPrec(q)
  }

  p_wall1 <- floor(p / 2)
  p_wall2 <- p_wall1 + 1
  q_wall1 <- floor(q / 2)
  q_wall2 <- q_wall1 + 1


  ## initialize
  beta1 <- rep(0, p)
  beta2 <- rep(0, p)
  gamma1 <- rep(0, q)
  gamma2 <- rep(0, q)


  if (type == "sparse") {
    beta1 <- rep(c(1, 0), c(2, p - 2))
    beta2 <- rep(c(0, 1), c(p - 2, 2))
    gamma1 <- rep(c(1, 0), c(2, q - 2))
    gamma2 <- rep(c(0, 1), c(q - 2, 2))
  } else if (type == "constant") {
    beta1[1:p_wall1] <- 1
    beta2[p_wall2:p] <- 1
    gamma1[1:q_wall1] <- 1
    gamma2[q_wall2:q] <- 1
  } else if (type == "random") {
    beta1[1:p_wall1] <- rnorm(p_wall1)
    beta2[p_wall2:p] <- rnorm(p - p_wall2 + 1)
    gamma1[1:q_wall1] <- rnorm(q_wall1)
    gamma2[q_wall2:q] <- rnorm(q - q_wall2 + 1)
  }

  beta1 <- normalize_wrtIP(beta1, sxx)
  beta2 <- normalize_wrtIP(beta2, sxx)
  gamma1 <- normalize_wrtIP(gamma1, syy)
  gamma2 <- normalize_wrtIP(gamma2, syy)



  syx_tmp <- rho1 * gamma1 %*% t(beta1) + rho2 * gamma2 %*% t(beta2)
  syx <- syy %*% syx_tmp %*% sxx

  sigma <- matrix(NA, p + q, p + q)
  sigma[1:p, 1:p] <- sxx
  sigma[(p + 1):(p + q), (p + 1):(p + q)] <- syy
  sigma[(p + 1):(p + q), 1:p] <- syx
  sigma[1:p, (p + 1):(p + q)] <- t(syx)

  return(sigma)
}

gen_sPrec <- function(p) {
  omega <- matrix(0, p, p)

  omega[abs(row(omega) - col(omega)) == 1] <- 0.5
  omega[abs(row(omega) - col(omega)) == 2] <- 0.4

  ## add a breakwall
  wall1 <- floor(p / 2)
  wall2 <- wall1 + 1

  omega[wall1, ] <- 0
  omega[, wall1] <- 0
  omega[wall2, ] <- 0
  omega[, wall2] <- 0

  ## set the diagonal
  omega[abs(row(omega) - col(omega)) == 0] <- 1

  sigma <- solve(omega)
  return(sigma)
}

## Normalize with respect to inner product, x is vector to normalize, s is
## matrix that induces inner product
normalize_wrtIP <- function(x, s) {
  magnitude <- drop(t(x) %*% s %*% x)
  x0 <- x / sqrt(magnitude)
  return(x0)
}

## like pracma::randortho but without the bug
randortho_fixed <- function(n, type = c("orthonormal", "unitary")) {
    stopifnot(is.numeric(n), length(n) == 1,
              floor(n) == ceiling(n), n >= 1)
    if (n == 1)
        return(matrix(1, 1, 1))

    type <- match.arg(type)
    if (type == "orthonormal") {
        z <- pracma::randn(n, n) / sqrt(2.0)
    } else {
        z <- (pracma::randn(n, n) + 1i * pracma::randn(n, n)) / sqrt(2.0)
    }

    # QR decomposition for real or complex matrices
    Z <- qr(z)
    q <- qr.Q(Z)
    r <- qr.R(Z)

    d <- diag(r)
    ph <- d / abs(d)
    q %*% diag(ph)
}

##' Compute the Canonical Correlation Analysis solution based on a
##' covariance matrix
##'
##' The Canonical Correlation Analysis problem can be solved in a
##' variety of ways. The approach taken by the cancor function in R
##' performs QR decomposition on the data matrices and proceeds from
##' there. However, it is also possible to find the canonical
##' correlations and associated weights using only the covariance
##' matrix. This is especially useful if one wishes to solve the
##' "population" version of CCA for a distribution with population
##' covariance Sigma. This algorithm results in canonical variates
##' that have unit empirical variance.
##'
##' @title Canonical Correlation Analysis for Covariance Matrix
##' @param Sigma A PSD matrix given the covariance (sample or population)
##' @param px The number of variables in the x dataset
##' @param align A function to perform post-processing on the estimated
##'   coefficients to render the solution well-identified. By default, this uses
##'   cca_align_posdiag, which ensures that the diagonal of xcoef is
##'   non-negative.
##' @param ref Passed through to alignment
##' @return A list containing the following components:
##'
##' cor: correlations
##'
##' xcoef: estimated coefficients for the x variables
##'
##' ycoef: estimated coefficients for the y variables
##' @author Daniel Kessler
##' @export cancor_cov
cancor_cov <- function(Sigma, px, align = cca_align_nil, ref) {
  p <- nrow(Sigma)
  sxx <- Sigma[1:px, 1:px]
  syy <- Sigma[(px + 1):p, (px + 1):p]
  syx <- Sigma[(px + 1):p, 1:px]

  sxx.sqrti <- solve(expm::sqrtm(sxx))
  syy.sqrti <- solve(expm::sqrtm(syy))

  SVD <- svd(syy.sqrti %*% syx %*% sxx.sqrti)

  rho <- SVD$d
  xcoef <- sxx.sqrti %*% SVD$v
  ycoef <- syy.sqrti %*% SVD$u

  svd(Sigma)
  fm <- list(cor = rho, xcoef = xcoef, ycoef = ycoef)
  align <- parse_align(align)
  fm <- align(fm, ref)
  return(fm)
}

cancor_cov_fiddle <- function(sigma, p, fiddle.var, fiddle.comp, fiddle.val) {

  fm_orig <- cancor_cov(sigma, p)
  fm_new <- fm_orig

  if (fiddle.var == "x") {
    fm_new$xcoef <- cancor_direction_fiddle(
      fm_new$xcoef, fiddle.comp, fiddle.val)
  } else if (fiddle.var == "y") {
    fm_new$ycoef <- cancor_direction_fiddle(
      fm_new$ycoef, fiddle.comp, fiddle.val)
  }
  sigma_new <- cancor_inv_cov(fm_new$xcoef, fm_new$ycoef, fm_new$cor)
  return(sigma_new)
}

## x is matrix of directions
cancor_direction_fiddle <- function(x, comp, val) {
  p <- nrow(x)
  if (val == "0") {
    newval <- 0
  } else if (val == "mean") {
    newval <- mean(abs(x[, comp]))
  } else if (val == "max") {
    newval <- max(abs(x[, comp]))
  }

  sgn <- nonneg(x[p, comp])
  x[p, comp] <- sgn * newval
  return(x)
}

##' Given canonical directions and correlations, find an associated covariance matrix
##'
##' In the same way that cancor_cov maps from a covariance matrix to a
##' correspond CCA solution, it is possible to map from a CCA solution to a
##' covariance matrix. However, this map is generally not unique.
##'
##' Given canonical correlations along with canonical directions for x and y,
##' respectively, this function will return a covariance matrix Sigma such that
##' calling cancor_cov on Sigma will return the same parameterization.
##'
##' Note that when p is not equal to q, there is ambiguity in the specification
##' of the covariance matrix for the larger random vector. The current approach
##' involves pseudoinverses, but these present difficulties for downstream
##' matrix operations. As a fix, we "fortify" the otherwise rank-deficient
##' matrices by increasing their trailing eigenvalues.
##' @title Inverse Map from CCA to Covariance
##' @param xcoef Canonical directions for the x variables (matrix)
##' @param ycoef Canonical directions for the y variables (matrix)
##' @param rho Canonical correlations (vector)
##' @return A square covariance matrix of size p + q
##' @author Dan Kessler
cancor_inv_cov <- function(xcoef, ycoef, cor) {
  K <- length(cor)
  p <- nrow(xcoef)
  q <- nrow(ycoef)


  pxcoef <- pracma::pinv(xcoef)
  pycoef <- pracma::pinv(ycoef)

  sxx <- t(pxcoef) %*% pxcoef
  syy <- t(pycoef) %*% pycoef

  ## address epsilon-small trailing eigenvalues
  if (p > K) {
    sxx <- cov_fortify(sxx, K)
  }
  if (q > K) {
    syy <- cov_fortify(syy, K)
  }

  syx <- syy %*% ycoef %*% diag(cor, nrow = K, ncol = K) %*% t(xcoef) %*% sxx

  Sigma <- matrix(NA, p + q, p + q)
  Sigma[1:p, 1:p] <- sxx
  Sigma[(p+1):(p+q), (p+1):(p+q)] <- syy
  Sigma[(p + 1):(p + q), 1:p] <- syx
  Sigma[1:p, (p + 1):(p + q)] <- t(syx)
  return(Sigma)
}
##' Fortify a covariance matrix by growing all eigenvalues past the K'th
##'
##' Some of our procedures may produce a covariance matrix that is very nearly
##' rank deficient, i.e., eigenvalues past the K'th may be arbitrarily small.
##' This function will attempt to remedy this by replacing all eigenvalues after
##' the K'th with new values that are nonzero. Specifically, it will linearly
##' interpolate between the smallest eigenvalue and 0 (without including either
##' endpoint).
##' @title Fortify a covariance matrix
##' @param cov
##' @return Fortified covariance matrix
##' @author Dan Kessler
cov_fortify <- function(cov, K){
  p <- nrow(cov)
  eigs <- eigen(cov)
  lmax <- eigs$values[K]
  lnew <- seq(from = lmax, to = 0, length.out = p - K + 2)[2:(p - K + 1)]
  eigs$values[(K+1):p] <- lnew

  cov_new <- with(eigs, vectors %*% diag(values) %*% t(vectors))
}

##' Return the (signed) value of the maximum (in magnitude) element of a vector
##'
##' An example is especially illustrative. absmax(c(1,-3,2)) will
##' yield -3. absmax(c(1,-2,3)) will yield 3.
##' @title Find Maximum Magnitude Element of Vector
##' @param x A vector
##' @return the signed maximum
##' @author Daniel Kessler
absmax <- function(x) {
  x[which.max(abs(x))]
}

## vectorized version of cancor for use with boot
cancor_vec <- function(data, p, align, ref) {
  q <- ncol(data) - p
  x <- data[, 1:p]
  y <- data[, (p + 1):(p + q)]
  fm <- cancor_scaled(x, y)
  align <- parse_align(align)
  fm <- align(fm, ref)
  theta <- fm2vec(fm)
  return(theta)
}


## * Batchtools Interfaces

##' This is a convenience function for use with batchtools
##'
##' TODO: Write details for sPrec
##' @title Batchtools convenience function for "problem"
##' @param job Constructed by batchtools
##' @param data Optionally, pass a list with named elements `x` and `y`, where
##'   each is an n by p and n by q matrix, respectively. Or, if `sigma` is true,
##'   then pass a single square covariance matrix of dimension (p + q)
##' @param data_is_sigma If true, treat "data" as sigma: a square covariance
##'   matrix of dimension (p + q)
##' @param pq A string like "p,q" with dimensions of the random variables X, Y
##' @param n The number of observations
##' @param cov_type Specifies covariance structure for X and Y. If "id", then
##'   both have identity covariance matrices. If "sPrec", then both will
##'   covariance corresponding to sparse precision matrices (see details).
##' @param rho1 Largest canonical correlation
##' @param rho2 Second largest canonical correlation
##' @param fiddle.var Coefficients of which variable you want to modify
##' @param fiddle.comp Component whose last coordinate you want to modify
##' @param fiddle.val String, one of "0", "mean", or "max"
##' @param inreps 
##' @return An instance
##' @author Daniel Kessler
##' @export
bt_problem_std_fun <- function(job = NULL, data = NULL, data_is_sigma = FALSE,
                               pq = NULL, n = NULL,
                               cov_type = c("id", "sPrec")[1],
                               rho1 = 0.9,
                               rho2 = 0,
                               fiddle.var = NULL,
                               fiddle.comp = NULL,
                               fiddle.val = NULL,
                               inreps = 1L,
                               type = NULL) {

  if (is.character(pq)) {
    pq_num <- as.integer(unlist(strsplit(pq, split = ",", fixed = TRUE)))
    p <-  pq_num[1]
    q <- pq_num[2]
  }

  prob_fun_inner <- function(use_data = FALSE) {
    res <- list()
    if (use_data) res$data <- data # use data
    if (!use_data) res$data <- gen_data(sigma, p, q, n) # make data
    res$fm_hat <- cancor_scaled(res$data$x, res$data$y)
    return(res)
  }

  ## initialize
  instance <- list()
  instance$inreps <- list()

  if (!is.null(data) && !data_is_sigma) { # use the data as passed
    instance$inreps[1] <- prob_fun_inner(use_data = TRUE)
  }

  if (!is.null(data) && data_is_sigma) { # sigma passed as data
    sigma <- data
    if (!is.null(fiddle.var)) { # modify sigma
      sigma <- cancor_cov_fiddle(sigma, p, fiddle.var, fiddle.comp, fiddle.val)
    }
    instance$inreps <- replicate(inreps, prob_fun_inner(), simplify = FALSE)
  }

  if (is.null(data)) { # do it from scratch
    sigma <- gen_sigma2(p, q, cov_type, rho1, rho2, type)
    instance$inreps <- replicate(inreps, prob_fun_inner(), simplify = FALSE)
  }

  if (data_is_sigma || is.null(data)) { # if we have ground truth, record it
    instance$fm_true <- cancor_cov(sigma, p)
  }

  return(instance)
}

##' @title Generic inrep function for batchtools algorithms
##' @param inrep The inrep object
##' @param ci_func A function that follows the cca_ci_* API
##' @param met_func A function to compute performance metrics
##' @param fm_true The true parameters
##' @param ... Arguments passed on to ci_func and met_func
##' @return CIs as returned by ci_func
##' @author Dan Kessler
##' @export
bt_algo_inrep <- function(inrep, ci_func, met_func, fm_true, ...) {
  cis <- ci_func(
    x = inrep$data$x,
    y = inrep$data$y,
    ref = inrep$fm_hat,
    ...
  )
  res <- met_func(fm_true, cis, ...)
  return(res)
}

##' @title Batchtools Function for Asymptotic Confidence Intervals
##' @param job required by batchtools
##' @param data required by batchtools
##' @param instance required by batchtools
##' @param ... Arguments passed on to ci_func
##' @return CI object
##' @export
##' @author Dan Kessler
bt_algo_asymptotic <- function(job, data, instance, ...) {
  res_inreps <- lapply(instance$inreps, bt_algo_inrep,
    ci_func = cca_ci_asymptotic,
    met_func = cca_metric_standard,
    fm_true = instance$fm_true,
    ...
  )
  res <- data.table::rbindlist(res_inreps, idcol= "inrep.id")
  return(res)
}


##' @title Batchtools Function for Laha-based Confidence Intervals
##' @param job required by batchtools
##' @param data required by batchtools
##' @param instance required by batchtools
##' @param ... Arguments passed on to ci_func
##' @return CI object
##' @export
##' @author Dan Kessler
bt_algo_laha <- function(job, data, instance, ...) {
  res_inreps <- lapply(instance$inreps, bt_algo_inrep,
    ci_func = cca_ci_laha,
    met_func = cca_metric_standard,
    fm_true = instance$fm_true,
    ...
  )
  res <- data.table::rbindlist(res_inreps, idcol = "inrep.id")
  return(res)
}

##' @title Batchtools Function for Bootstrapped Abs
##' @param job required by batchtools
##' @param data required by batchtools
##' @param instance required by batchtools
##' @param ... Arguments passed on to ci_func
##' @return CI object
##' @export
##' @author Dan Kessler
bt_algo_absboot <- function(job, data, instance, ...) {
  res_inreps <- lapply(instance$inreps, bt_algo_inrep,
    ci_func = cca_ci_absboot,
    met_func = cca_metric_standard,
    fm_true = instance$fm_true,
    ...
  )
  res <- data.table::rbindlist(res_inreps, idcol= "inrep.id")
  return(res)
}

##' @title Batchtools Function for Regression-Based CIs
##' @param job required by batchtools
##' @param data required by batchtools
##' @param instance required by batchtools
##' @param ... Arguments passed on to ci_func
##' @return CI object
##' @export
##' @author Dan Kessler
bt_algo_regression <- function(job, data, instance, ...) {
  res_inreps <- lapply(instance$inreps, bt_algo_inrep,
    ci_func = cca_ci_regression,
    met_func = cca_metric_standard,
    fm_true = instance$fm_true,
    ...
  )
  res <- data.table::rbindlist(res_inreps, idcol= "inrep.id")
  return(res)
}

##' @title Batchtools Function for Bootstrapped Confidence Intervals
##' @param job required by batchtools
##' @param data required by batchtools
##' @param instance required by batchtools
##' @param ... Arguments passed on to ci_func
##' @return CI object
##' @export
##' @author Dan Kessler
bt_algo_boot <- function(job, data, instance, ...) {
  res_inreps <- lapply(instance$inreps, bt_algo_inrep,
    ci_func = cca_ci_boot,
    met_func = cca_metric_boots,
    fm_true = instance$fm_true,
    ...
  )
  res <- data.table::rbindlist(res_inreps, idcol= "inrep.id")
  return(res)
}


## * More utility functions
fm2mat <- function(fm) rbind(fm$xcoef, fm$ycoef)

fm2vec <- function(fm) mat2vec(fm2mat(fm))

mat2fm <- function(mat, p) {
  fm <- list()
  fm$xcoef <- mat[1:p, ]
  fm$ycoef <- mat[(p + 1):nrow(mat), ]
  return(fm)
}

procrustes <- function(A, B) {
  M <- B %*% t(A)
  SVD <- svd(M)
  R <- SVD$u %*% t(SVD$v)
  return(R)
}

mat2vec <- function(mat) c(mat)

vec2fm <- function(vec, p, q) mat2fm(vec2mat(vec, p, q), p)

vec2mat <- function(vec, p, q) matrix(vec, nrow = p + q)

## Like sign, but return +1 for 0
nonneg <- function(x) {
  signs <- sign(x)
  signs[signs == 0] <- 1
  return(signs)
}

## threshold a cancor object, setting any values smaller than thresh in
## magnitude to 0. if any canonical correlations are smaller than thresh,
## zero-out their associated directions
cancor_thresh <- function(fm, thresh = 1e-10) { #
  K <- length(fm$cor)

  cor_mask <- abs(fm$cor) >= thresh
  fm$cor[cor_mask] <- 0

  cor_mask_mat <- diag(x = cor_mask, nrow = K, ncol = K)

  fm$xcoef <- fm$xcoef %*% cor_mask_mat
  fm$ycoef <- fm$ycoef %*% cor_mask_mat

  fm$xcoef[abs(fm$xcoef) < thresh] <- 0
  fm$ycoef[abs(fm$ycoef) < thresh] <- 0

  return(fm)
}


varival <- function(x) {
  ## compute the value of the varimax objective for matrix x
  n <- nrow(x)
  k <- ncol(x)

  squares <- 1 / n^2 * colSums(x^2)^2
  fourths <- 1 / n * colSums(x^4)

  v <- sum(fourths - squares)
  return(v)
}

varival_relative <- function(x) {
  ## compute the RELATIVE value of the varimax objective for matrix x. This is
  ## found by maximizing and minimizing varival over right rotations, and then
  ## rescaling
  Qmax <- varimax(x, normalize = FALSE)$rotmat
  vmax <- varival(x %*% Qmax)

  Qmin <- psych::varimin(x, normalize = FALSE)$Th
  vmin <- varival(x %*% Qmin)

  v <- varival(x)

  v_rel <- (v - vmin) / vmax

  return(v_rel)
}


## * Assess Coverage

##' @title Compute the best possible coverage of CCA CIs (allowing both sign
##'   flips and reassignments)
##' @param fm_true The "true" fitted model
##' @param cis Confidence intervals
##' @param xyweight A number in [0, 1] indicating how much to weigh coverage of
##'   x's directions vs y's. If NULL, they are weighted by p and q. If 0, this
##'   only cares about matching x, if 1, only cares about matching y.
##' @return Mean coverage
##' @author Dan Kessler
##' @export
cca_ci_coverage_pangloss <- function(fm_true, cis, xyweight = NULL) {
  covs <- cca_ci_coverage_possibilities(fm_true, cis)

  if (is.null(xyweight)) {
    p <- nrow(fm_true$xcoef)
    q <- nrow(fm_true$ycoef)

    xyweight <- p / (p + q)
  }

  cov_pos <- xyweight * covs$xcov_pos + (1 - xyweight) * covs$ycov_pos
  cov_neg <- xyweight * covs$xcov_neg + (1 - xyweight) * covs$ycov_neg

  cov_posneg <- abind::abind(cov_pos, cov_neg, along = 3)
  cov_best <- apply(cov_posneg, c(1, 2), max)

  C <- hungarian_max_signflip(cov_best)

  cov_optimal <- cov_best %*% C

  cov_mean <- mean(diag(cov_optimal))
  return(cov_mean)
}

##' @title Compute the coverage of CCA CIs allowing sign flips
##' @inheritParams cca_ci_coverage_pangloss
##' @return data table of coverage by variable by component
##' @author Dan Kessler
##' @export
cca_ci_coverage_signflip <- function(fm_true, cis, xyweight = NULL) {
  K <- length(fm_true$cor)

  covs <- cca_ci_coverage_possibilities(fm_true, cis)

  if (is.null(xyweight)) {
    p <- nrow(fm_true$xcoef)
    q <- nrow(fm_true$ycoef)

    xyweight <- p / (p + q)
  }

  cov_pos <- xyweight * covs$xcov_pos + (1 - xyweight) * covs$ycov_pos
  cov_neg <- xyweight * covs$xcov_neg + (1 - xyweight) * covs$ycov_neg

  cov_posneg <- abind::abind(cov_pos, cov_neg, along = 3)
  cov_best_ind <- diag(apply(cov_posneg, c(1, 2), which.max))

  cov_best_sign <- ifelse(cov_best_ind == 1, 1, -1)
  sign_flip_mat <- diag(cov_best_sign)

  ## it's actually easier to "flip" the true parameter
  ## O/w, we have to swap upper/lower confidence bounds, too
  fm_true_flip <- fm_true
  fm_true_flip$xcoef <- fm_true$xcoef %*% sign_flip_mat
  fm_true_flip$ycoef <- fm_true$ycoef %*% sign_flip_mat

  res <- list()

  res$covs <- cca_ci_coverage_raw(fm_true_flip, cis)
  res$true <- cca_ci_true(fm_true_flip, cis)
  return(res)
}


##' @title Compute All Possible Coverages of CCA CIs
##' @param fm_true The result of cancor_cov
##' @param cis A list with xcoef and ycoef, which are p x k x 2 and q x k x 2,
##'   respectively
##' @return A list containing four k x k matrices of coverage by components
##'   under various assignment schemes. Rows index components of fm_true,
##'   columns index components of cis. xcov_pos holds coverage for x without
##'   sign flipping, xcov_neg holds coverage for x after a -1 sign flip,
##'   ycov_pos and ycov_neg are analaogous.
##' @author Dan Kessler
cca_ci_coverage_possibilities <- function(fm_true, cis) {
  k <- length(fm_true$cor)

  empty <- matrix(NA, k, k)
  res <- list(xcov_pos = empty,
              xcov_neg = empty,
              ycov_pos = empty,
              ycov_neg = empty)

  for (i in 1:k) {
    for (j in 1:k) {
      res$xcov_pos[i, j] <- cca_ci_coverage1(fm_true$xcoef[, i], cis$xcoef[, j, ])
      res$xcov_neg[i, j] <- cca_ci_coverage1(-1 * fm_true$xcoef[, i],
                                       cis$xcoef[, j, ])

      res$ycov_pos[i, j] <- cca_ci_coverage1(fm_true$ycoef[, i], cis$ycoef[, j, ])
      res$ycov_neg[i, j] <- cca_ci_coverage1(-1 * fm_true$ycoef[, i],
                                       cis$ycoef[, j, ])
    }
  }
  return(res)
}

##' @title Compute the lengths of CCA CIs
##' @param cis A list with xcoef and ycoef, which are each arrays with
##'   dimensions p x K x 2 and q x K x 2, respectively
##' @return A data.table of lengths
##' @author Dan Kessler
cca_ci_lengths <- function(cis) {
  lengths <- list()
  lengths$x <- cca_ci_lengths1(cis$xcoef)
  lengths$y <- cca_ci_lengths1(cis$ycoef)

  res <- data.table::rbindlist(lengths, idcol = "variable")
  return(res)
}

cca_ci_lengths1 <- function(cis_coef) {
  p <- dim(cis_coef)[1]
  K <- dim(cis_coef)[2]

  lengths <- apply(cis_coef, c(1, 2), diff)

  res <- data.table::data.table(
    metric = "length",
    component = rep(1:K, each = p),
    coordinate = 1:p,
    value = c(lengths)
  )
  return(res)
}

## Compute the endpoints of confidence intervals
cca_ci_ends <- function(cis) {
  ends <- list()
  ends$x <- cca_ci_ends1(cis$xcoef)
  ends$y <- cca_ci_ends1(cis$ycoef)

  res <- data.table::rbindlist(ends, idcol = "variable")
  return(res)
}

cca_ci_ends1 <- function(cis_coef) {
  p <- dim(cis_coef)[1]
  K <- dim(cis_coef)[2]

  lower <- cis_coef[, , 1]
  upper <- cis_coef[, , 2]

  res_lower <- data.table::data.table(
    metric = "CI_lower",
    component = rep(1:K, each = p),
    coordinate = 1:p,
    value = c(lower)
  )

  res_upper <- data.table::data.table(
    metric = "CI_upper",
    component = rep(1:K, each = p),
    coordinate = 1:p,
    value = c(upper)
  )

  res <- data.table::rbindlist(list(res_lower, res_upper))

  return(res)
}


##' @title Compute CI coverage for a vector
##' @param true A vector of length p
##' @param cis A matrix of size p x 2; first column is lower bound of CI, second
##'   column is upper bound of CI
##' @return A scalar in [0, 1] with the proportion of covered intervals
##' @author Dan Kessler
cca_ci_coverage1 <- function(true, cis) {
  res <- mean(cis[, 1] <= true & true <= cis[, 2])
  return(res)
}

##' Solve a more generalized version of the Hungarian Algorithm.
##'
##' The classic Hungarian Algorithm solves P = argmin_P trace(C * P), where P is
##' constrained to be a permutation matrix. Here, we instead solve T = argmax_T
##' trace(C * T), where T is the composition of a column-permutation matrix and
##' a column-wise sign-flipping matrix. Note that this differs from the classic
##' Hungarian algorithm in that we (1) maximize the utility of the assignments,
##' (2) are allowed to flip the sign of any of our utility values.
##' @title Solve the Hungarian Algorithm (maximizing assignment) but with Sign
##'   Flipping Allowed
##' @param C k1 x k2 matrix of assignment costs.
##' @return Square matrix with k2^2 elements; composition of permutation and
##'   sign flipping matrix.
##' @author Dan Kessler
hungarian_max_signflip <- function(C) {
  k1 <- nrow(C)
  k2 <- ncol(C)
  if (k1 > k2) stop("Algorithm ill-defined for tall C matrix")

  C_check <- abs(C)
  C_check <- max(C_check) - C_check # flip around to maximize while staying nn

  sol_abs <- RcppHungarian::HungarianSolver(C_check)
  P_star <- matrix(0, k1, k2)
  P_star[sol_abs$pairs] <- 1
  P_star <- t(P_star)

  signs <- c(diag(nonneg(C %*% P_star)))

  D_star <- diag(signs)

  P <- P_star %*% D_star
  return(P)
}

cca_metric_standard <- function(fm_true, cis, ...) {
  ## compute lengths and coverages
  tmp <- cca_ci_coverage_signflip(fm_true, cis)
  covs <- tmp$covs
  true <- tmp$true
  ends <- cca_ci_ends(cis)
  lengths <- cca_ci_lengths(cis)
  sigdet <- cca_ci_sigdet(fm_true, cis)
  h0 <- cca_ci_h0(fm_true, cis)
  res <- rbind(covs, true, ends, lengths, sigdet, h0)
  return(res)
}

cca_metric_boots <- function(fm_true, cis_list, ...) {
  ## special handler to loop over multiple cis from boot

  names(cis_list)
  res_list <- lapply(cis_list, cca_metric_standard, fm_true = fm_true)
  res <- data.table::rbindlist(res_list, idcol = "BootMethod")
  return(res)

}

cca_ci_coverage_raw <- function(fm_true, cis) {
  ## Compute coverage by variable, by component, and by coordinate. No
  ## adjustment is done for sign flipping or alignment

  covs <- list()
  covs$x <- cca_ci_coverage_raw1(fm_true$xcoef, cis$xcoef)
  covs$y <- cca_ci_coverage_raw1(fm_true$ycoef, cis$ycoef)

  coverage <- data.table::rbindlist(covs, idcol = "variable")
  return(coverage)
}

cca_ci_coverage_raw1 <- function(true_coef, cis_coef) {
  ## Compute coverage for a single variable by coordinate
  p <- nrow(true_coef)
  K <- ncol(true_coef)

  cover <- as.numeric(cis_coef[, , 1] <= true_coef & true_coef <= cis_coef[, , 2])

  res <- data.table::data.table(
                       metric = "coverage",
                       component = rep(1:K, each = p),
                       coordinate = 1:p,
                       value = cover)
  return(res)
}

cca_ci_sigdet <- function(fm_true, cis) {
  fm_true <- cancor_thresh(fm_true)

  sigdets <- list()
  sigdets$x <- cca_ci_sigdet1(fm_true$xcoef, cis$xcoef)
  sigdets$y <- cca_ci_sigdet1(fm_true$ycoef, cis$ycoef)

  sigdet <- data.table::rbindlist(sigdets, idcol = "variable")
  return(sigdet)
}

cca_ci_sigdet1 <- function(true_coef, cis_coef) {
  p <- nrow(true_coef)
  K <- ncol(true_coef)


  ci_nz <- cis_coef[, , 1] >= 0 | 0 >= cis_coef[, , 2]
  true_nz <- true_coef != 0

  ## bit encoding:
  ## true_nz: 1 if nonzero, 0 if zero
  ## ci_nz: 2 if CI does not contain zero, 0 if it does
  ## take the sum, and get this table
  ## 0: True Negative
  ## 1: False Negative
  ## 2: False Positive
  ## 3: True Positive
  sigdet <- true_nz + (2 * ci_nz)

  res <- data.table::data.table(
    metric = "sigdet",
    component = rep(1:K, each = p),
    coordinate = 1:p,
    value = c(sigdet)
  )

  return(res)
}

cca_ci_h0 <- function(fm_true, cis) {
  fm_true <- cancor_thresh(fm_true)

  h0s <- list()
  h0s$x <- cca_ci_h01(fm_true$xcoef, cis$xcoef)
  h0s$y <- cca_ci_h01(fm_true$ycoef, cis$ycoef)

  h0 <- data.table::rbindlist(h0s, idcol = "variable")
  return(h0)

}


cca_ci_h01 <- function(true_coef, cis_coef) {
  p <- nrow(true_coef)
  K <- ncol(true_coef)


  h0 <- cis_coef[, , 1] >= 0 | 0 >= cis_coef[, , 2]

  res <- data.table::data.table(
    metric = "h0",
    component = rep(1:K, each = p),
    coordinate = 1:p,
    value = c(h0)
  )

  return(res)
}


cca_ci_true <- function(fm_true, cis) {
  fm_true <- cancor_thresh(fm_true)

  trues <- list()
  trues$x <- cca_ci_true1(fm_true$xcoef, cis$xcoef)
  trues$y <- cca_ci_true1(fm_true$ycoef, cis$ycoef)

  true <- data.table::rbindlist(trues, idcol = "variable")
  return(true)
}


cca_ci_true1 <- function(true_coef, cis_coef) {
  p <- nrow(true_coef)
  K <- ncol(true_coef)

  res <- data.table::data.table(
    metric = "TrueValue",
    component = rep(1:K, each = p),
    coordinate = 1:p,
    value = c(true_coef)
  )

  return(res)
}
